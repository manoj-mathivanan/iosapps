//  ODPRequest.h
//  SUPProxyClient
/***************************************************************/
//  Created by M, Pramod on 1/10/12.
//  Copyright (c) Sybase, An SAP Company. All rights reserved.
/***************************************************************/

#import <Foundation/Foundation.h>
#import <CFNetwork/CFNetwork.h>




#if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
#import <UIKit/UIKit.h> // Necessary for background task support
#endif

#import <stdio.h>

/**
 * Defines authentication related constants.
 */
typedef enum EAuthenticationState {
	NoAuthenticationNeededYet = 0,  ///< no authentication needed
	HTTPAuthenticationNeeded = 1,   ///< server with basic authentication requests credentials
	ProxyAuthenticationNeeded = 2   ///< proxy authentication required
} AuthenticationState;

/**
 * Defines common error types (connection and internal library malfunction related constants).
 */
typedef enum ENetworkErrorType {
    ConnectionFailureErrorType = 1,		///< Connection Failure
    RequestTimedOutErrorType = 2,		///< Timeout
    AuthenticationErrorType = 3,		///< Authentication problem
    RequestCancelledErrorType = 4,		///< HTTP request cancelled
    UnableToCreateRequestErrorType = 5, ///< Request creation error
    InternalErrorWhileBuildingRequestType  = 6, ///< Denotes an internal library error
    InternalErrorWhileApplyingCredentialsType  = 7, ///< Denotes an internal library error
	FileManagementError = 8,            ///< Issues while storing / loading files
	TooMuchRedirectionErrorType = 9,    ///< Redirection limit exceeded
	UnhandledExceptionError = 10,       ///< This one caught us unprepared
	InternalServerError = 11            ///< response status code 500 received from the server	
} NetworkErrorType;

extern NSString* const NetworkRequestErrorDomain1; ///< The error domain that all errors generated by HTTPRequest use
/**
 This is an integer constant used for checking inside the onConfigurationChange callback that CustomizationResourceBundle is changed in SCC.
 */
extern NSInteger kCustResourceBundlePropID;
/**
 This is an Integer constant being used for checking inside the onConfigurationChange callback that Password Policy is being changed in SCC. 
 */
extern NSInteger kPasswordPolicyChanged;
/**
 * Consists of methods for handling HTTP requests.
 * @remark Wrapper around CFNetwork
 * <pre>
 * Features:
 * <ul>
 * <li> Synchronous and asynchronous execution
 * <li> Continues downloading and uploading when app is sent to the background (iOS 4.0+ only)
 * <li> Network Queue for batch http request processing and progress tracking
 * <li> Protected download cache; encrypted offline storage of downloaded content (iOS 4.0+ only)
 * <li> Secure connection (iOS 4.0+ only)
 * <li> Easy to extend
 * <li> Progress tracking
 * </ul>
 * </pre>
 */

#ifdef USE_ODP_INTERFACE

typedef enum {
    EtagIfMatch,
    EtagIfNoneMatch,
    EtagIfRange
} EtagMatchType;

@interface ODPRequest : NSOperation <NSCopying> {
    
#else   
    
#import "SDMRequesting.h"
#import "SDMHttpRequestDelegate.h"
#import "SDMProgressDelegate.h"
    
    
    @interface ODPRequest : NSOperation <SDMRequesting, NSCopying> {
        
#endif
        
        
        //! The url for this operation, should include GET params in the query string where appropriate
        NSURL* m_Url; 
        
        //! Will always contain the original url used for making the request (the value of url can change when a request is redirected)
        NSURL* m_OriginalURL;
        
        //! HTTP method to use (GET / POST / PUT / DELETE / HEAD). Defaults to GET
        NSString* m_RequestMethod;
        
#ifdef USE_ODP_INTERFACE
        id m_Delegate;
        id m_Queue;    
#else
        //! The delegate, you need to manage setting and talking to your delegate in your subclasses
        id <SDMHttpRequestDelegate> m_Delegate;
        
        /**
         * Another delegate that is also notified of request status changes and progress updates
         * Generally, you will not use this directly, but SDMNetworkQueue sets itself as the queue so it can proxy updates to its own delegates
         * @remark Will be retained by the request
         */
        id <SDMHttpRequestDelegate, SDMProgressDelegate> m_Queue;
	    
#endif
        
        //  PerformanceAgent * m_perfAgent;
        //E2ETraceController* m_traceController;
        //E2ETraceTransaction* m_traceTrans;
        
        
        //! Request body - only used when the whole body is stored in memory (shouldStreamPostDataFromDisk is false)
        NSMutableData* m_PostBody;
        
        /** When true, post body will be streamed from a file on disk, rather than loaded into memory at once (useful for large uploads)
         * Automatically set to true in FormDataRequests when using setFile:forKey:
         */
        BOOL m_ShouldStreamPostDataFromDisk;
        
        /**
         * Path to file used to store post body (when shouldStreamPostDataFromDisk is true)
         * You can set this yourself - useful if you want to PUT a file from local disk 
         */
        NSString* m_PostBodyFilePath;
        
        /**
         * Path to a temporary file used to store a deflated post body (when shouldCompressPostBody is YES)
         */
        //	NSString* m_CompressedPostBodyFilePath;
        
        /**
         * Set to true when HTTPRequest automatically created a temporary file containing the request body 
         * (when true, the file at postBodyFilePath will be deleted at the end of the request)
         */
        BOOL m_DidCreateTemporaryPostDataFile;	
        
        /* E2E Testing */
        BOOL m_UploadToSolutionManager;
        /* E2E Testing */
        
        
        //! Dictionary for custom HTTP request headers
        NSMutableDictionary* m_RequestHeaders;
        
        //! Set to YES when the request header dictionary has been populated, used to prevent this happening more than once
        BOOL m_HaveBuiltRequestHeaders;
        
        //! Will be populated with HTTP response headers from the server
        NSDictionary* m_ResponseHeaders;
        
        //! Can be used to manually insert cookie headers to a request, but it is more likely that sessionCookies will do this for you
        NSMutableArray* m_RequestCookies;
        
        //! If useCookiePersistence is true, network requests will present valid cookies from previous requests
        BOOL m_UseCookiePersistence;
        
        //! If useKeychainPersistence is true, network requests will attempt to read credentials from the keychain, and will save them in the keychain when they are successfully presented
        BOOL m_UseKeychainPersistence;
        
        //! If useSessionPersistence is true, network requests will save credentials and reuse for the duration of the session (until clearSession is called)
        BOOL m_UseSessionPersistence;
        
        //! If allowCompressedResponse is true, requests will inform the server they can accept compressed data, and will automatically decompress gzipped responses. Default is true.
        BOOL m_AllowCompressedResponse;
        
        /**
         * If shouldCompressRequestBody is true, the request body will be gzipped. Default is false.
         * You will probably need to enable this feature on your webserver to make this work. Tested with apache only.
         */
        BOOL m_ShouldCompressRequestBody;
        
        /**
         * When downloadDestinationPath is set, the result of this request will be downloaded to the file at this location
         * If downloadDestinationPath is not set, download data will be stored in memory
         */
        NSString* m_DownloadDestinationPath;
        
        //! The location that files will be downloaded to. Once a download is complete, files will be decompressed (if necessary) and moved to downloadDestinationPath
        NSString* m_TemporaryFileDownloadPath;
        
        //! external "finished" indicator, subject of KVO notifications; updates after 'complete'
        BOOL m_Finished;
        
        //! True if our 'cancel' selector has been called
        BOOL m_Cancelled;
        
        /**
         * If an error occurs, error will contain an NSError
         * If error code is = ConnectionFailureErrorType (1, Connection failure occurred) - inspect [[error userInfo] objectForKey:NSUnderlyingErrorKey] 
         * for more information	
         */
        NSError* m_Error;
        
        //! Username used for authentication
        NSString* m_Username;
        //! Password used for authentication
        NSString* m_Password;
        
        //! Domain used for NTLM authentication
        NSString* m_Domain;
        
        //! Username used for proxy authentication
        NSString* m_ProxyUsername;
        //! Password used for proxy authentication
        NSString* m_ProxyPassword;
        
        //! Domain used for NTLM proxy authentication
        NSString* m_ProxyDomain;
        
        
#ifdef USE_ODP_INTERFACE
        //! Define dummmy delegates for upload and download progress delegates
        id m_UploadProgressDelegate;
        id m_DownloadProgressDelegate;
        id m_DownloadCache;
#else
        //! Delegate for displaying upload progress (usually an NSProgressIndicator, but you can supply a different object and handle this yourself)
        id <SDMProgressDelegate> m_UploadProgressDelegate;
        
        //! Delegate for displaying download progress (usually an NSProgressIndicator, but you can supply a different object and handle this yourself)
        id <SDMProgressDelegate> m_DownloadProgressDelegate;
        
        /**
         * The download cache that will be used for this request (use [HTTPRequest setDefaultCache:cache] to configure a default cache
         */
        id <SDMCacheDelegate> m_DownloadCache;
#endif
        //! Whether we've seen the headers of the response yet
        BOOL m_HaveExaminedHeaders;
        
        //! Data we receive will be stored here. Data may be compressed unless allowCompressedResponse is false - you should use [request responseData] instead in most cases
        NSMutableData* m_RawResponseData;
        
        //! Used for sending requests and receiving responses
        CFHTTPMessageRef m_Request;
        
        //! Used for authentication
        CFHTTPAuthenticationRef m_RequestAuthentication; 
        
        //! Authentication scheme (Basic, Digest, NTLM)
        NSString* m_AuthenticationScheme;
        
        //! Used for proxy authentication
        CFHTTPAuthenticationRef m_ProxyAuthentication;
        //! proxy credentials 
        NSDictionary* m_ProxyCredentials;
        
        //! Indicates whether a credentials dialog should be presented for authentication
        BOOL m_ShouldPresentAuthenticationDialog;
        
        //! Indicates whether a credentials dialog should be presented for proxy authentication
        BOOL m_ShouldPresentProxyAuthenticationDialog;
        
        //! Authentication scheme for the proxy (Basic, Digest, NTLM)
        NSString* m_ProxyAuthenticationScheme;	
        
        //! Size of the POST payload
        unsigned long long m_PostLength;	
        
        //! Called on the delegate (if implemented) when the request starts. Default is requestStarted:
        SEL m_DidStartSelector;
        
        //! Called on the delegate (if implemented) when the request receives response headers. Default is requestDidReceiveResponseHeaders:
        SEL m_DidReceiveResponseHeadersSelector;
        
        //! Called on the delegate (if implemented) when the request completes successfully. Default is requestFinished:
        SEL m_DidFinishSelector;
        
        //! Called on the delegate (if implemented) when the request fails. Default is requestFailed:
        SEL m_DidFailSelector;
        
        /**
         * Called on the delegate (if implemented) when the request receives data. Default is request:didReceiveData:
         * If you set this and implement the method in your delegate, you must handle the data yourself - HTTPRequest will not populate 
         * responseData or write the data to downloadDestinationPath
         */
        SEL m_DidReceiveDataSelector;
        
        
        //! Number of seconds to wait before timing out - default is DEFAULT_CONNECTION_TIMEOUT_SECONDS
        NSTimeInterval m_TimeOutSeconds;
        
        //! Will be YES when a HEAD request will handle the content-length before this request starts
        BOOL m_ShouldResetUploadProgress;
        BOOL m_ShouldResetDownloadProgress;
        
        //! Used by HEAD requests when showAccurateProgress is YES to preset the content-length for this request
        ODPRequest* m_MainRequest;
        
        /**
         * When NO, this request will only update the progress indicator when it completes
         * When YES, this request will update the progress indicator according to how much data it has received so far
         * The default for requests is YES
         */
        BOOL m_ShowAccurateProgress;
        
        //! Prevents the body of the post being built more than once (largely for subclasses)
        BOOL m_HaveBuiltPostBody;
        
        //! Text encoding for responses that do not send a Content-Type with a charset value. Defaults to NSUTF8StringEncoding
        NSStringEncoding m_DefaultResponseEncoding;
        
        //! Tells HTTPRequest not to delete partial downloads, and allows it to use an existing file to resume a download. Defaults to NO.
        BOOL m_AllowResumeForFileDownloads;
        
        //! Custom user information associated with the request
        NSDictionary* m_UserInfo;
        
        //! Use HTTP 1.0 rather than 1.1 (defaults to false)
        BOOL m_UseHTTPVersionOne;
        
        //! When YES, requests will automatically redirect when they get a HTTP 30x header (defaults to YES)
        BOOL m_ShouldRedirect;
        
        //! When NO, requests will not check the secure certificate is valid (use for self-signed certificates during development, DO NOT USE IN PRODUCTION) Default is YES
        BOOL m_ValidatesSecureCertificate;
        
        //! If not nil and the URL scheme is https, CFNetwork configured to supply a client certificate
        SecIdentityRef m_ClientCertificateIdentity;
        NSArray* m_ClientCertificates;
        
        //! Details on the proxy to use - you can set these yourself, but it is probably best to let HTTPRequest detect the system proxy settings
        NSString* m_ProxyHost;
        int m_ProxyPort;
        
        /**
         * HTTPRequest will assume kCFProxyTypeHTTP if the proxy type could not be automatically determined
         * Set to kCFProxyTypeSOCKS if you are manually configuring a SOCKS proxy
         */
        NSString* m_ProxyType;
        
        //! URL for a PAC (Proxy Auto Configuration) file. If you want to set this yourself, it is probably best if you use a local file
        NSURL* m_PACurl;
        
        //! See AuthenticationState values above. 0 == default == No authentication needed yet
        AuthenticationState m_AuthenticationNeeded;
        
        /**
         * When YES, HTTPRequests will present credentials from the session store for requests to the same server before being asked for them
         * This avoids an extra round trip for requests after authentication has succeeded, which is efficient for authenticated requests with large bodies, 
         * or on slower connections
         * Set to NO to only present credentials when explicitly asked for them
         * This only affects credentials stored in the session cache when useSessionPersistence is YES. Credentials from the keychain are never presented unless the server asks for them
         * Default is YES
         */
        BOOL m_ShouldPresentCredentialsBeforeChallenge;
        
        /**
         * Set to allow a request to automatically retry itself on timeout
         * Default is zero - timeout will stop the request
         */
        int m_RetryCountOnTimeout;
        
        /** 
         * When YES, requests will keep the connection to the server alive for a while to allow subsequent requests to re-use it for a substantial speed-boost
         * Persistent connections will not be used if the server explicitly closes the connection
         * Default is YES
         */
        BOOL m_ShouldAttemptPersistentConnection;
        
        /** 
         * Number of seconds to keep an inactive persistent connection open on the client side
         * Default is 60
         * If we get a keep-alive header, this value is replaced with how long the server told us to keep the connection around
         * A future date is created from this and used for expiring the connection, this is stored in connectionInfo's expires value
         */
        NSTimeInterval m_PersistentConnectionTimeoutSeconds;
        
        /**
         * When set to YES, 301 and 302 automatic redirects will use the original method and and body, according to the HTTP 1.1 standard
         * Default is NO (to follow the behaviour of most browsers)
         */
        BOOL m_ShouldUseRFC2616RedirectBehaviour;
        
        /**
         * An ID that uniquely identifies this request - primarily used for debugging persistent connections
         */
        NSNumber* m_RequestID;
        
        BOOL m_DidUseCachedResponse;
        
        /**
         * Set secondsToCache to use a custom time interval for expiring the response when it is stored in a cache
         */
        NSTimeInterval m_SecondsToCache;
        
#if TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
        /**
         * Flag controlling whether http requests should run in the background (defaults to true)
         * @remark available since iOS4.0 and above
         */	
        BOOL m_ShouldContinueInBackground;
        /**
         * Background task ID used when the request executes in the background
         */
        UIBackgroundTaskIdentifier m_BackgroundTask;
#endif
        
        NSTimer* m_StatusTimer; ///< timer used to monitor request status changes
    }
    
#pragma mark -
#pragma mark Initialization and deallocation
    
    /**
     * HTTP or HTTPS URL. It may include username and password if appropriate.
     */
    - (id)initWithURL:(NSURL *)newURL;
    
    /**
     * Convenience constructor with URL.
     * @param URL 
     * @result ODPRequest object
     * <pre>
     * Usage 
     * <code>
     * ODPRequest * l_request=[ODPRequest requestWithURL:[NSURL URLWithString:Url]];
     * .... add the necessary request headers
     *
     * </code>
     * </pre>
     */    
    + (id)requestWithURL:(NSURL *)newURL;
    
#ifndef USE_ODP_INTERFACE
    
    /**
     * Convenience constructor with URL and cache.
     * @param URL 
     * @param Cache
     * @result ODPRequest object
     * <pre>
     * Usage 
     * <code>
     * ODPRequest * l_request=[ODPRequest requestWithURL:[NSURL URLWithString:Url] usingCache:cache];
     * .... add the necessary request headers
     *
     * </code>
     * </pre>
     */    
    + (id)requestWithURL:(NSURL *)newURL usingCache:(id <SDMCacheDelegate>)cache;
    
    /**
     * Convenience constructor with URL, cache, and cache policy.
     * @param URL 
     * @param Cache
     * @result ODPRequest object.
     * <pre>
     * Usage 
     * <code>
     * ODPRequest * l_request=[ODPRequest requestWithURL:[NSURL URLWithString:Url] usingCache:cache andCachePolicy:policy];
     * .... add the necessary request headers
     *
     * </code>
     * </pre>
     */    
    + (id)requestWithURL:(NSURL *)newURL usingCache:(id <SDMCacheDelegate>)cache andCachePolicy:(CachePolicy)policy;
    
#endif
    
    /**
     * Sets the maximum number of ODPRequest threads that can be executed at the same time.
     * @throws SDMConnectivityException If maximum number of allowed parallel threads is exceeded.
     */
    + (void) setMaxConcurrentHTTPRequestCount:(const unsigned char) cnt;
    /**
     * Returns the maximum number of ODPRequest threads which can be executed in parallel
     */
    + (NSInteger) getMaxConcurrentHTTPRequestCount;
    
#pragma mark -
#pragma mark Request Setup
    
    /**
     * Adds a custom header to the request.
     * @see buildRequestHeaders
     * @param header Header name.
     * @param value Header value.
     * <pre>
     * Usage 
     * <code>
     *
     * [l_request addRequestHeader:headerName value:HeaderValue];
     * </code>
     * </pre>
     */
    - (void)addRequestHeader:(NSString *)header value:(NSString *)value;
    
    /**
     * Creates a cookie header from request cookies and global store, when called during buildRequestHeaders after a redirect.
     */
    - (void)applyCookieHeader;
    
    /**
     * Populates the request headers dictionary. It is called before a request is started, or by a HEAD request to borrow the headers.
     */
    - (void)buildRequestHeaders;
    
    /*
     * Used to apply authorization header to a request before it is sent (when shouldPresentCredentialsBeforeChallenge is YES)
     */
    - (void)applyAuthorizationHeader;
    
    /**
     * Adds data to the post body. Appends to postBody when shouldStreamPostDataFromDisk is set to false, or write to postBodyWriteStream when set to true.
     * <pre>
     * Usage
     * <code>
     * ODPRequest *request=[ODPRequest requestWithURL:[NSURL URLWithString:endpointUrl]];
     * [request setUsername:@"smpuser"];
     * [request setPassword:@"s3puser"];
     * [request setRequestMethod:@"POST"];
     * [request appendPostData:data];
     * [request startSynchronous];
     * </code>
     * </pre>
     */
    - (void)appendPostData:(NSData *)data;
    /**
     * Adds data to the post body from a file. Appends to postBody when shouldStreamPostDataFromDisk is set to false, or writes to postBodyWriteStream when set to true.
     * <pre>
     * Usage
     * <code>
     * NSString *documentsDirectory = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
     * NSString *filePath = [documentsDirectory stringByAppendingPathComponent:@"uploadData.xml"];
     * ODPRequest *request=[ODPRequest requestWithURL:[NSURL URLWithString:endpointUrl]];
     * [request setUsername:@"smpuser"];
     * [request setPassword:@"s3puser"];
     * [request setRequestMethod:@"POST"];
     * [request appendPostDataFromFile:filePath];
     * [request startSynchronous];
     * </code>
     * </pre>
     */
    - (void)appendPostDataFromFile:(NSString *)file;
    
    /**
     * Creates the post body
     */
    - (void)buildPostBody;
    
    /**
     * Adds If-Match or If-None-Match or If-Range header.
     */
    - (void)setEtag:(NSString *)etag withMatchType:(EtagMatchType) matchType;
    
    /**
     * Enables XCSRF support. It is disabled by default.
     * @param Boolean for enabling or disabling the XCSRF support.
     * <pre>
     * Usage 
     * <code>
     *
     * [ODPRequest enableXCSRF:YES/NO];
     * </code>
     * </pre>
     */
    + (void)enableXCSRF:(BOOL) enable;
    
#pragma mark -
#pragma mark Request Payload
    
    /**
     * Returns the contents of the result as an NSString. It is not appropriate for binary data, use responseData instead.
     * @see responseData
     * @result String data
     * <pre>
     * Usage 
     * <code>
     *
     * [l_request responseString];
     * </code>
     * </pre>
     */
    - (NSString *)responseString;
    
    /**
     * Response data, automatically uncompressed where appropriate.
     * @see responseString
     * @result Binary data
     * <pre>
     * Usage 
     * <code>
     *
     * [l_request responseData];
     * </code>
     * </pre>
     */
    - (NSData *)responseData;
    
    /**
     * Returns true if the response is gzip compressed.
     * @result True or false depending on whether the response is gzip or not.
     * <pre>
     * Usage 
     * <code>
     *
     * [l_request isResponseCompressed];
     * </code>
     * </pre>
     */
    - (BOOL)isResponseCompressed;
    
#pragma mark-
#pragma mark E2E tracing
    
    /**
     * If tracing is enabled, this method starts preparing BTX.
     * <pre>
     *  Usage
     * <code>
     *  @try{
     *      [ODPRequest startTrace];
     *   }
     *  @catch(NSException *e){
     *      // catch exception here
     *  }
     * </code>
     * </pre>
     */
    
    +(void)startTrace;
    
    /**
     * Disables the tracing (if enabled) and stops generating BTX.
     * <pre>
     *  Usage
     * <code>
     *  @try{
     *      [ODPRequest stopTrace];
     *   }
     *  @catch(NSException *e){
     *      // catch exception here
     *  }
     * </code>
     * </pre>
     */
    +(void)stopTrace;
    
    
    /*!
     @method
     @abstract Uploads the generated BTX to Solution Manager server.
     @param error:      Double pointer to the error object if the function returns an error.            
     @discussion Uploads the generated BTX to Solution Manager. If the method fails, it will throw an error.
     
     * <pre>
     *  Usage
     * <code>
     *  NSError* error = nil;
     *  [ODPRequest uploadTraceWithError:&error];
     *  if (!error) 
     *  {
     *      // Further processing
     *  }
     * </code>
     * </pre>
     */   
    
    +(void)uploadTraceWithError:(NSError**)error;    
    
    +(void)bumpToTextFile:(NSString*)xml;    
    
#pragma mark -
#pragma mark Request execution
    /**
     * Executes a request synchronously, and returns control when the request completes or fails.
     * <pre>
     * Usage 
     * <code>
     * ODPRequest * l_request=[ODPRequest requestWithURL:[NSURL URLWithString:endpointUrl]];
     * .... add the necessary request headers
     *
     * [l_request startSynchronous];
     * </code>
     * </pre>
     */
    - (void)startSynchronous;
    
    /**
     * Executes the request in the background.
     * The client should register the callback selector to get notified about various events such as failure, completion, and so on.
     * <pre>
     * Usage 
     * <code>
     * ODPRequest * l_request=[ODPRequest requestWithURL:[NSURL URLWithString:endpointUrl]];
     * .... add the necessary request headers
     *
     * [l_request startAsynchronous];
     * </code>
     * </pre>
     */
    - (void)startAsynchronous;
    
#pragma mark -
#pragma mark HEAD request
    
    /**
     * Used by NetworkQueue to create a HEAD request appropriate for this request with the same headers.
     */
    - (ODPRequest *)HEADRequest;
    
#pragma mark -
#pragma mark Upload / Download progress
    
    /**
     * Updates the progress delegates.
     * @remark Used by SDMNetworkQueue, and should not be invoked directly by clients.
     */
    - (void)updateProgressIndicators;
    
    /**
     * Updates upload progress (notifies the queue and/or uploadProgressDelegate of this request).
     */
    - (void)updateUploadProgress;
    
    /**
     * Updates download progress (notifies the queue and/or downloadProgressDelegate of this request).
     */
    - (void)updateDownloadProgress;
    
    /**
     * Called when authorization is required, as you can determine that you do not have permissions only when the upload is complete.
     */
    - (void)removeUploadProgressSoFar;
    
    /**
     * Called when you get a content-length header and shouldResetDownloadProgress is set to true.
     */
    - (void)incrementDownloadSizeBy:(long long)length;
    
    /**
     * Called when a request starts and shouldResetUploadProgress is set to true.
     * It is also called (with a negative length) to remove the size of the underlying buffer used for upload.
     */
    - (void)incrementUploadSizeBy:(long long)length;
    
    /**
     * Helper method for interacting with progress indicators to abstract the details of different APIS (NSProgressIndicator and UIProgressView).
     */
    + (void)updateProgressIndicator:(id *)indicator withProgress:(unsigned long long)progress ofTotal:(unsigned long long)total;
    
    /**
     * Helper method used for performing invocations on the main thread (used for progress).
     */
    + (void)performSelector:(SEL)selector onTarget:(id *)target withObject:(id)object amount:(void *)amount;
    
    
#pragma mark -
#pragma mark Http Authentication
    
    /**
     * Unlocks the request thread so it can resume the request.
     * @remark This method should be called by delegates once the authentication information is populated after an authentication challenge.
     */
    - (void)retryUsingSuppliedCredentials;
    
    /** Called by delegates to cancel authentication and stop.
     */
    - (void)cancelAuthentication;
    /**
     * Constructs a basic authentication header from the user name and password specified, and adds it to the request headers. It is used when the variable shouldPresentCredentialsBeforeChallenge is set to YES.
     * <pre>
     * Usage
     * <code>
     * ODPRequest *request=[ODPRequest requestWithURL:[NSURL URLWithString:endpointUrl]];
     * [request addBasicAuthenticationHeaderWithUsername:@"smpuser" andPassword:@"s3puser"];
     * [request startSynchronous];
     * </code>
     * </pre>
     */
    - (void)addBasicAuthenticationHeaderWithUsername:(NSString *)theUsername andPassword:(NSString *)thePassword;
    
#pragma mark -
#pragma mark CFnetwork Event Handlers
    /**
     * Handles network events as they occur
     * @remark It is called from ReadStreamClientCallBack method when one of the events requested in NETWORK_EVENTS occurs.
     */
    - (void)handleNetworkEvent:(CFStreamEventType)type;
    
#pragma mark -
#pragma mark Request Failure Management
    
    /**
     * Called when a request fails, and lets the delegate know via didFailSelector.
     */
    - (void)failWithError:(NSError *)theError;
    
    
#pragma mark -
#pragma mark Client Certificate Handling
    //! Sets the identity reference (X.509 certificate and private key) for this request. It is used for secure connections.
    - (void)setClientCertificateIdentity:(SecIdentityRef)anIdentity;
    
    
#pragma mark 
#pragma mark Keychain Storage
    
    //! Saves credentials for this request to the keychain
    - (void)saveCredentialsToKeychain:(NSDictionary *)newCredentials;
    
    //! Saves host credentials to the keychain
    + (void)saveCredentials:(NSURLCredential *)credentials forHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
    //! Saves proxy credentials to the keychain
    + (void)saveCredentials:(NSURLCredential *)credentials forProxy:(NSString *)host port:(int)port realm:(NSString *)realm;
    
    //! Returns host credentials from the keychain
    + (NSURLCredential *)savedCredentialsForHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
    //! Returns proxy credentials from the keychain
    + (NSURLCredential *)savedCredentialsForProxy:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
    
    //! Deletes host credentials from the keychain
    + (void)removeCredentialsForHost:(NSString *)host port:(int)port protocol:(NSString *)protocol realm:(NSString *)realm;
    //! Deletes proxy credentials from the keychain
    + (void)removeCredentialsForProxy:(NSString *)host port:(int)port realm:(NSString *)realm;
    
#pragma mark -
#pragma mark Session Management
    
    // Dump all session data (authentication and cookies)
    + (void)clearSession;
    
#pragma mark -
#pragma mark Reachability
    
    //! Returns YES when an iPhone OS device is connected via WWAN, false when connected via WIFI or not connected.
    + (BOOL)isNetworkReachableViaWWAN;
    
#pragma mark -
#pragma mark Concurrent Request Queue
    
    //! Returns the shared queue
    + (NSOperationQueue *)sharedQueue;
    
#ifndef USE_ODP_INTERFACE    
    
#pragma mark -
#pragma mark Cache Management
    /**
     * Configures a default download cache which applies for all requests.
     * @see SDMDownloadCache
     */
    + (void)setDefaultCache:(id <SDMCacheDelegate>)cache;
    /**
     * Returns the default download cache or nil if no value is set at class level.
     */
    + (id <SDMCacheDelegate>)defaultCache;
    
#endif    
    
#pragma mark -
#pragma mark Network Activity
    /**
     * Indicates whether there are running requests.
     * @return NO, if no requests are currently executing.
     */
    + (BOOL)isNetworkInUse;
    /**
     * Controls whether the request should take over updating the network activity indicator. It is enabled by default.
     */
    + (void)setShouldUpdateNetworkActivityIndicator:(BOOL)shouldUpdate;
    
    //! Shows the network activity spinner
    + (void)showNetworkActivityIndicator;
    
    //! Hides the network activity spinner
    + (void)hideNetworkActivityIndicator;
    
#pragma mark -
#pragma mark Bandwidth Measurement / Throttling
    /**
     * Maximum approximate number of bytes all requests can send or receive in a second.
     * This does not include HTTP headers.
     */
    + (unsigned long)maxBandwidthPerSecond;
    //! Sets the maximum number of bytes all requests can send or receive in a second.
    + (void)setMaxBandwidthPerSecond:(unsigned long)bytes;
    
    /**
     * Returns an average (for the last five seconds) of how much bandwidth is used, in bytes.
     */
    + (unsigned long)averageBandwidthUsedPerSecond;
    /**
     * Performs bandwidth throttling.
     */
    - (void)performThrottling;
    
    //! Returns YES if bandwidth throttling is currently in use.
    + (BOOL)isBandwidthThrottled;
    
    //! Records bandwidth use and used by InputStreams during upload.
    + (void)incrementBandwidthUsedInLastSecond:(unsigned long)bytes;
    
    /**
     * ODPRequest automatically turns throttling on and off as the connection type changes between WWAN and WiFi.
     * Set to YES to automatically turn on throttling when WWAN is connected.
     */
    + (void)setShouldThrottleBandwidthForWWAN:(BOOL)throttle;
    
    //! Turns on throttling automatically when WWAN is connected using a custom limit.
    + (void)throttleBandwidthForWWANUsingLimit:(unsigned long)limit;
    
    //! Returns the maximum amount of data that can be read as part of the current measurement period, and retires the thread if the allowance is consumed.
    + (unsigned long)maxUploadReadLength;
    
#pragma mark
#pragma mark Mime-type Detection
    
    // Return the mime type for a file
    + (NSString *)mimeTypeForFileAtPath:(NSString *)path;
    
#pragma mark -
#pragma mark Secure File Storage 
    /**
     * Controls whether the download cache should store files using protection. It is enabled by default and applies to all instances.
     * @remark It is available for builds targeting iOS 4.0 or above.	
     */
    +(void) setProtectionEnabled:(BOOL)flag_in;
    
    /**
     * Returns an attributes dictionary used for encrypted file storage or nil if file protection has been explicitly disabled.
     * @remark File protection is enabled by default for builds targeting iOS4.0 and above. You can change it using SDMHttpRequest +setProtectionEnabled.
     * @see setProtectionEnabled:
     */
    +(NSDictionary*) fileProtectionAttributes;
    
    /**
     * Returns a mask which determines whether the data should be stored in encrypted form.
     * @remark Data is stored in encrypted form by default.
     */
    +(const NSDataWritingOptions) dataWritingOptions;
    
#pragma mark -
#pragma mark Utility Methods
    
    //! Base64 encodes the provided NSData*
    + (NSString*) base64forData:(NSData*)theData;
    //! Decodes a base64 encoded string
    + (NSString*) decodeBase64:(NSString*)string_in;
    
    //! Returns a date from a string in RFC1123 format
    + (NSDate *)dateFromRFC1123String:(NSString *)string;
    
#pragma mark -
#pragma mark Assignable Selectors
    /**
     * Clients can choose to register their custom selectors to be invoked.
     * @remark You can consider implementing the SDMHttpRequestDelegate as an alternative to this approach.
     * <pre>
     * Usage (client side)
     * <code>
     * // register the client as delegate for this request
     * [m_AsynchRequest setDelegate:self];
     * [m_AsynchRequest setDidStartSelector:@selector(serviceDocFetchStarted:)];
     * ...
     * </code>
     * </pre>
     */
    @property (assign) SEL didStartSelector;
    /**
     * Clients can choose to register their custom selectors to be invoked.
     * @remark You can consider implementing the SDMHttpRequestDelegate as an alternative to this approach.
     * <pre>
     * Usage (client side)
     * <code>
     * // register the client as delegate for this request
     * [m_AsynchRequest setDelegate:self];
     * [m_AsynchRequest setDidFinishSelector:@selector(serviceDocFetchComplete:)];
     * ...
     * </code>
     * </pre>
     */
    @property (assign) SEL didFinishSelector;
    /**
     * Clients can choose to register their custom selectors to be invoked.
     * @remark You can consider implementing the SDMHttpRequestDelegate as an alternative to this approach.
     * <pre>
     * Usage (client side)
     * <code>
     * // register the client as delegate for this request
     * [m_AsynchRequest setDelegate:self];
     * [m_AsynchRequest setDidFailSelector:@selector(serviceDocFetchFailed:)];
     * ...
     * </code>
     * </pre>
     */
    @property (assign) SEL didFailSelector;
    /**
     * Clients can choose to register their custom selectors to be invoked.
     * The default delegate method is invoked when incoming data is available.
     * @remark Implement this delegate to manually process all incoming data (usually not required). With this, the responseData or responseString are ignored.
     * 
     * <pre>
     * Usage (client side)
     * <code>
     * // register the client as delegate for this request
     * [m_AsynchRequest setDelegate:self];
     * [m_AsynchRequest setDidReceiveDataSelector:@selector(dataArrived:)];
     * ...
     * </code>
     * </pre>
     */
    @property (assign) SEL didReceiveDataSelector;
    /**
     * Clients can choose to register their custom selectors to be invoked.
     * <pre>
     * Usage (client side)
     * <code>
     * // register the client as delegate for this request
     * [m_AsynchRequest setDelegate:self];
     * [m_AsynchRequest setDidReceiveResponseHeadersSelector:@selector(headersReceived:)];
     * ...
     * </code>
     * </pre>
     */
    @property (assign) SEL didReceiveResponseHeadersSelector;
    
    -(void)setChunkSize:(int)size;    
    -(int)getChunkSize;
    -(void)setMoOffset:(unsigned long)offset;
    -(unsigned long)getMoOffset;
    
#pragma mark -
#pragma mark Accessors
    
    // !!! private properties
    @property (retain, readonly) NSString* authenticationRealm;
    @property (retain, readonly) NSString* proxyAuthenticationRealm;
    @property (assign, readonly) BOOL complete;
    @property (retain, readonly) NSArray* responseCookies;
    @property (assign, readonly) int responseStatusCode; ///< HTTP status code, i.e. 200 = OK, 404 = Not found etc
    @property (retain, readonly) NSString* responseStatusMessage;
    @property (assign, readonly) unsigned long long contentLength;
    @property (assign, readonly) unsigned long long partialDownloadSize;
    @property (assign, readonly) unsigned long long totalBytesRead;
    @property (assign, readonly) unsigned long long totalBytesSent;
    @property (assign, readonly) AuthenticationState authenticationNeeded;
    @property (assign, readonly) int authenticationRetryCount;
    @property (assign, readonly) int proxyAuthenticationRetryCount;
    @property (assign, readonly) BOOL inProgress;
    @property (assign, readonly) int retryCount;
    @property (assign, readonly) BOOL connectionCanBeReused;
    @property (retain, readonly) NSNumber* requestID;
    @property (assign, readonly) BOOL didUseCachedResponse;
    // private properties end
    
    
    @property (nonatomic, retain) NSString* corelationId;           /* DOE Specific Property */
    
    @property (retain) NSString* username;
    @property (retain) NSString* password;
    @property (retain, readwrite) NSString* moCookie;
    @property (retain) NSString* domain;
    @property (retain) NSString* proxyUsername;
    @property (retain) NSString* proxyPassword;
    @property (retain) NSString* proxyDomain;
    @property (retain) NSString* proxyHost;
    @property (assign) int proxyPort;
    @property (retain) NSString* proxyType;
    @property (retain) NSURL* url;
    @property (retain) NSURL* originalURL;
    @property (assign, nonatomic) id delegate;
    @property (retain, nonatomic) id queue;
    @property (assign, nonatomic) id uploadProgressDelegate;
    @property (assign, nonatomic) id downloadProgressDelegate;
    @property (assign) BOOL useKeychainPersistence;
    @property (assign) BOOL useSessionPersistence;
    @property (retain) NSString* downloadDestinationPath;
    @property (retain) NSString* temporaryFileDownloadPath;
    
    /* E2E Testing */
    @property (assign) BOOL uploadToSolutionManager;
    /* E2E Testing */   
    
    @property (retain) NSError* error;
    @property (retain) NSDictionary* responseHeaders;
    @property (retain) NSMutableDictionary* requestHeaders;
    @property (retain) NSMutableArray* requestCookies;
    @property (assign) BOOL useCookiePersistence;
    @property (retain) NSDictionary* requestCredentials;
    @property (retain) NSDictionary* proxyCredentials;
    @property (retain) NSMutableData* rawResponseData;
    @property (assign) NSTimeInterval timeOutSeconds;
    @property (retain) NSString* requestMethod;
    @property (retain) NSMutableData* postBody;
    @property (assign) unsigned long long postLength;
    @property (assign) BOOL shouldResetDownloadProgress;
    @property (assign) BOOL shouldResetUploadProgress;
    @property (assign) ODPRequest* mainRequest;
    @property (assign) BOOL showAccurateProgress;
    @property (assign) NSStringEncoding defaultResponseEncoding;
    @property (assign, readonly) NSStringEncoding responseEncoding;
    @property (assign) BOOL allowCompressedResponse;
    @property (assign) BOOL allowResumeForFileDownloads;
    @property (retain) NSDictionary *userInfo;
    @property (retain) NSString *postBodyFilePath;
    @property (assign) BOOL shouldStreamPostDataFromDisk;
    @property (assign) BOOL didCreateTemporaryPostDataFile;
    @property (assign) BOOL useHTTPVersionOne;
    @property (assign) BOOL shouldRedirect;
    @property (assign) BOOL validatesSecureCertificate;
    @property (assign) BOOL shouldCompressRequestBody;
    @property (retain) NSURL* PACurl;
    @property (retain) NSString* authenticationScheme;
    @property (retain) NSString* proxyAuthenticationScheme;
    @property (assign) BOOL shouldPresentAuthenticationDialog;
    @property (assign) BOOL shouldPresentProxyAuthenticationDialog;
    @property (assign) BOOL shouldPresentCredentialsBeforeChallenge;
    @property (assign) BOOL haveBuiltRequestHeaders;
    @property (assign, nonatomic) BOOL haveBuiltPostBody;
    @property (assign) int retryCountOnTimeout;
    @property (assign) BOOL shouldAttemptPersistentConnection;
    @property (assign) NSTimeInterval persistentConnectionTimeoutSeconds;
    @property (assign) BOOL shouldUseRFC2616RedirectBehaviour;
    @property (assign) BOOL shouldAutosetLanguage; ///< controls whether the preferred language has to be passed along the request's header; defaults to YES
    /**
     * Configures a default download cache.
     * The download cache used for this request.
     * 
     * <pre>
     * Sample usage
     * <code> 
     * // assign a download cache instance to the request
     * <b>[m_Request setDownloadCache:[SDMDownloadCache instance]];</b>
     * // apply cache settings as required (see SDMDownloadCache)
     * [[SDMDownloadCache instance] setDefaultCachePolicy:OnlyLoadIfNotCachedCachePolicy];
     *
     * [m_Request setCacheStoragePolicy:CachePermanentlyCacheStoragePolicy];
     * </code>
     * </pre>
     * @see +setDefaultCache, SDMDownloadCache
     */
    
#ifndef USE_ODP_INTERFACE    
    @property (assign) id <SDMCacheDelegate> downloadCache;
    @property (assign) CachePolicy cachePolicy;
    @property (assign) CacheStoragePolicy cacheStoragePolicy;
#endif
    @property (assign) NSTimeInterval secondsToCache;
    @property (retain) NSArray* clientCertificates;
    
#if TARGET_OS_IPHONE && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_4_0
    /**
     * Controls background download/uplod behavior (enabled by default) for builds targeting iOS4.0+
     * @remark Will not work for iOS versions below 4.0
     */
    @property (assign, nonatomic) BOOL shouldContinueInBackground;
#endif
    
    @end
